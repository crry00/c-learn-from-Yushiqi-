如果`Base`类中的`show`方法被声明为`virtual`，那么在`main`函数中通过基类指针（如`pBase`，尽管在您提供的代码片段中`pBase`并未在`main`函数中直接使用，但假设它存在并被用来指向`Base`或其派生类的对象）调用`show`方法时，将发生多态行为。

多态允许通过基类指针或引用来调用派生类中的重写（override）方法。但是，在您给出的代码片段中，并没有直接展示`pBase`指针的使用，也没有展示`Base`类的派生类。不过，我们可以根据这些概念来推理。

如果`Base`类中的`show`是`virtual`的，并且存在一个或多个从`Base`派生的类，这些派生类重写了`show`方法，那么当您通过指向这些派生类对象的`Base`类指针（如`pBase`）调用`show`时，实际上会调用派生类中的`show`方法，而不是`Base`类中的原始`show`方法，除非指针实际上指向了一个`Base`类的对象。

然而，如果`pBase`确实指向了一个`Base`类的对象，并且您通过它调用了`show`方法，那么即使`show`是`virtual`的，也会调用`Base`类中的`show`方法，因为此时没有派生类的方法来覆盖它。

如果您想要在`main`函数中直接调用`Base`类的`show`方法（即使它是`virtual`的），并且您有一个`Base`类的对象（比如`Base obj;`），那么您可以直接在对象上调用它（`obj.show();`），这将调用`Base`类中定义的`show`方法，不考虑多态。

请注意，如果`main`函数中确实没有使用`pBase`指针，并且只是直接创建了一个`Base`类的对象并调用了它的`show`方法，那么多态将不会起作用，因为您没有通过基类指针或引用来调用方法。在这种情况下，无论`show`方法是否被声明为`virtual`，都将调用`Base`类中的`show`方法。

如果想通过父类指针调用`Deriver`类内的父类实现show函数，you can use p.Base::show()